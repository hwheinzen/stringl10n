// Copyright 2020 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/dullgiulio/jsoncomments"
	. "github.com/hwheinzen/stringl10n/mistake"
)

const head = `# This file was generated by l10nextract.
#
# Edit to make it the JSON input file for l10n.
#
# You can:
# - change copyright owner
# - change package name
# - change error type
# - change error prefix (package name in capitals recommended)
# - change GenFile name
# - delete entries which don't need translation
# - delete #-comments
#
# Then:
# - add translations to Texts
# - complete variables of template expressions to Vars
#   (Vars with Type other than standard need Path for import, but only once)
# - complete functions of template expressions to Funcs
#   (Funcs outside package need Path for import, but only once)
#
`

const empty = `{
	"Copyright": "2020 Itts Mee",
	"Package":   "pkg",
	"ErrorType": "Err",
	"ErrorPref": "PKG",
	"GenFile":   "l10n_generated.go",

	"Vars": [
	],

	"Funcs": [
	],

	"Texts": {
		"DUMMY": [{ "Lang":"DUMMY","Value":"DUMMY"}]
	}
}
` // EYECATCHER

type All struct {
	Copyright string
	Package   string
	ErrorType string
	ErrorPref string
	GenFile   string
	Vars      []struct {
		Name string
		Type string
		Path string `json:"Path,omitempty"`
	}
	Funcs []struct {
		Name     string
		Function string
		Path     string `json:"Path,omitempty"`
	}
	Texts map[string][]struct {
		Lang  string
		Value string
	}
}

var gData All // working copy of JSON data

func readJSON() error {
	fnc := "readJSON"

	var rdr io.Reader
	if argJSON != "" {
		file, err := os.Open(argJSON)
		if err != nil {
			e := Err{
				Fix: "L10NEXTRACT:open {{.Name}} failed",
				Var: []struct {
					Name  string
					Value interface{}
				}{
					{"Name", argJSON},
				},
			}
			return fmt.Errorf(fnc+":%w:"+err.Error(), e)
		}
		defer file.Close()
		rdr = file
	} else {
		buf := bytes.NewBufferString(empty)
		defer buf.Reset()
		rdr = buf
	}

	reader := jsoncomments.NewReader(rdr) // filters #-comments
	dec := json.NewDecoder(reader)

	err := dec.Decode(&gData)
	if err != nil {
		e := Err{
			Fix: "L10NEXTRACT:decode JSON from {{.Name}} failed",
			Var: []struct {
				Name  string
				Value interface{}
			}{
				{"Name", argJSON},
			},
		}
		return fmt.Errorf(fnc+":%w:"+err.Error(), e)
	}

	return nil
}

func makeJSON() (bytes []byte, err error) {
	fnc := "makeJSON"

	bytes, err = json.MarshalIndent(gData, "", "\t")
	if err != nil {
		e := Err{Fix: "L10NEXTRACT:marshal JSON failed"}
		return bytes, fmt.Errorf(fnc+":%w:"+err.Error(), e)
	}

	return bytes, nil
}
