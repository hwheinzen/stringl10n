// Copyright 2015-20 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

package main

var code = `// Copyright {{.Copyright}}. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY {{.Generator}}.
// ON {{.Generated}}. DO NOT EDIT.
// CHANGES WILL DISAPPEAR AFTER NEXT RUN OF {{.Generator}}.

/*
 {{.GenFile}} contains all localized strings and
 functions for translating (l10nTranslate)
 and substituting variables (l10nSubstitute).
*/

package {{.Package}}

import (
	"bytes"
	"encoding/json"
	"log"
	"text/template" {{if ne (len .Funcs) 0}}{{range .Funcs}}{{if ne .Path ""}}
	"{{.Path}}"{{end}}{{end}}{{end}}{{if ne (len .Vars) 0}}{{range .Vars}}{{if ne .Path ""}}
	"{{.Path}}"{{end}}{{end}}{{end}}
)

// Type l10nPair is used during string localization.
type l10nPair struct {
	Lang  string
	Value string
}

// l10nMap contains all key strings and all translations.
var l10nMap = make(map[string][]l10nPair, 10)

// L10nExists returns true if an entry of a given text exists.
func L10nExists(key string) bool {
	_, ok := l10nMap[key]
	return ok
}

// L10nTrans exports l10nTrans.
func L10nTrans(key, lang string) string {
	return l10nTrans(key, lang)
}

// l10nTrans returns a translation of a given text
// according to the chosen language code.
// Errors are logged.
func l10nTrans(key, lang string) (value string) {
	fnc := "l10nTrans"

	pairs, ok := l10nMap[key]
	if !ok {
		log.Print(fnc+": no entry for: ", key)
		return key
	}
	for _, v := range pairs {
		if v.Lang == lang {
			return v.Value
		}
	}
	//log.Print("l10nTrans: language: ", lang, " not defined for key: ", key)
	return key
}

// l10nVars declares all variables needed for substitution.
type l10nVars struct { {{range .Vars}}
	{{.Name}} {{.Type}}{{end}}
}

// Varser interface has a method that returns
// Name-string/Value-interface{} pairs.
type Varser interface {
	Vars() []struct{ // Vars returns Name-Value-Pairs
		Name string
		Value interface{}
	}
}

// l10nSubst is OBSOLETE. It uses l10nRepl to do the work.
func l10nSubst(tmpl string, pairs Varser) string {
	return l10nRepl(tmpl, pairs.Vars())
}

// L10nRepl exports l10nRepl.
func L10nRepl(tmpl string, vars []struct {
	Name string
	Value interface{}
}) string {
	return l10nRepl(tmpl, vars)
}

// l10nRepl resolves text/template expressions and returns
// the changed text string. Variables in these text/template 
// expressions are substituted by values.
// Errors are logged.
func l10nRepl(tmpl string, vars []struct {
	Name string
	Value interface{}
}) (out string) {
	fnc := "l10nRepl"

	t := template.New("tmpl"){{if eq (len .Funcs) 0}}
	_, err := t.Parse(tmpl){{else}}
	funcMap := template.FuncMap { {{range .Funcs}}
		"{{.Name}}": {{.Function}},{{end}}
	}
	_, err := t.Funcs(funcMap).Parse(tmpl){{end}}
	if err != nil {
		log.Print(err)
	}

	all := l10nVars{}

	for _, pair := range vars {
		switch pair.Name { {{range .Vars}}
		case "{{.Name}}":
			tmp, ok := pair.Value.({{.Type}})
			if !ok {
				log.Printf(fnc+": wrong type for: {{.Name}}, expected: {{.Type}}, got: %T\n", pair.Value)
				break
			}
			all.{{.Name}} = tmp{{end}}
		default:
			log.Printf(fnc+": %s not declared\n", pair.Name)			
		}
	}

	var buf bytes.Buffer
	err = t.Execute(&buf, all) // &buf is an io.Writer
	if err != nil {
		log.Print(err)
	}
	out = buf.String()

	return
}
`
