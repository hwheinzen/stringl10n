// Copyright 2015 Itts Mee. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY stringl10n.
// DO NOT EDIT.
// CHANGES WILL BE LOST AFTER NEXT //go:generate stringl10n ...

/*
 stringl10n_generated.go contains all localized strings and
 functions for translating (t alias l10nTranslate)
 and variable substitution (l10nSubstitute).
*/

package main

import (
	"encoding/json"
	"log"
	"text/template"

	"strings"
)

//var _ = strings.Replace  // clumsy workaround to ensure strings is imported (TODO)

// Type l10nPair is used during string localization.
type l10nPair struct {
	Lang  string
	Value string
}

// l10nMap contains all key strings and all translations.
var l10nMap = make(map[string][]l10nPair, 10)

// l10nTranslate returns a translation of a given text
// according to the chosen language code.
// Errors are logged.
func l10nTranslate(key, lang string) (value string) {
	pairs, ok := l10nMap[key]
	if !ok {
		log.Print("No entry for (text): " + key)
		return key
	}
	for _, v := range pairs {
		if v.Lang == lang {
			return v.Value
		}
	}
	log.Print("No entry for (language/text): " + lang + " / " + key)
	return key
}

// t conveniently points to the translate function.
var t = l10nTranslate

// l10nVars declares all variables needed for substitution.
type l10nVars struct { 
	I1 int
	Fl1 float64
	S1 Struktur
}

// Varser interface has a method that returns
// Name-string/Value-interface{} pairs.
type Varser interface {
	Vars() []struct{
		Name string
		Value interface{}
	}
}

// l10nSubstitute resolves text/template expressions and returns
// the changed text string. Variables in these text/template 
// expressions are substituted by values.
// Errors are logged.
func l10nSubstitute(tmpl string, vars Varser) (out string) {

	t := template.New("tmpl")
	funcMap := template.FuncMap { 
		"replace": strings.Replace,
		"trimr": strings.TrimRight,
	}
	_, err := t.Funcs(funcMap).Parse(tmpl)
	if err != nil {
		log.Print(err)
	}

	all := l10nVars{}
	for _, v := range vars.Vars() {
		switch v.Name { 
		case "I1":
			tmp, ok := v.Value.(int)
			if !ok {
				log.Printf("False type for variable I1, expected: int, got: %T\n", v.Value)
				break
			}
			all.I1 = tmp
		case "Fl1":
			tmp, ok := v.Value.(float64)
			if !ok {
				log.Printf("False type for variable Fl1, expected: float64, got: %T\n", v.Value)
				break
			}
			all.Fl1 = tmp
		case "S1":
			tmp, ok := v.Value.(Struktur)
			if !ok {
				log.Printf("False type for variable S1, expected: Struktur, got: %T\n", v.Value)
				break
			}
			all.S1 = tmp
		default:
			log.Printf("Variable %s not declared\n", v.Name)			
		}
	}
	
	p := l10nPointer{&out}
	err = t.Execute(p, all)
	if err != nil {
		log.Print(err)
	}

	return
}

// l10nPointer points to a string.
type l10nPointer struct {
	pointer *string
}

// Write makes l10nPointer an io.Writer
// that writes to the string it points to.
func (o l10nPointer) Write(p []byte) (n int, err error) {
	*(o.pointer) += string(p)
	n = len(p)
	return
}

func init() {
	err := json.Unmarshal([]byte(l10nJSON), &l10nMap)
	if err != nil {
		log.Fatal(err)
	}
	l10nJSON = "" // no longer needed
}

var l10nJSON = `{"1: {{printf \"%d\" .I1}} 2: {{printf \"%f\" .Fl1}}":[{"Lang":"en","Value":"One: {{printf \"%d\" .I1}} Two: {{trimr (printf \"%f\" .Fl1) \"0\"}}"},{"Lang":"de","Value":"Zwei: {{trimr (replace (printf \"%f\" .Fl1) \".\" \",\" -1) \"0\"}} Eins: {{printf \"%d\" .I1}}"},{"Lang":"ex","Value":"Struktur: {{print .S1}}"}],"address of the data server is missing":[{"Lang":"de","Value":"Adresse des Daten-Servers fehlt"},{"Lang":"en","Value":"address of the data server is missing"}],"help":[{"Lang":"de","Value":"Hilfe"},{"Lang":"en","Value":"help"}]}`
