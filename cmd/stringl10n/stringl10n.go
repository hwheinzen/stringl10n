// Copyright 2015 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

package main

import (
	"encoding/json"
	"errors"
	"log"
	"os"
	"strings"
	"text/template"
)

const (
	pgmname = "stringl10n"
)

type All struct {
	Copyright string
	Package   string
	GenFile   string
	Vars      []struct {
		Name string
		Type string
	}
	Funcs     []struct {
		Name     string
		Function string
		Path     string
	}
	Texts map[string][]struct {
		Lang  string
		Value string
	}
}

func main() {
	fn := args()
	file, err := os.Open(fn)
	if err != nil {
		log.Fatal(err)
	}

	dec := json.NewDecoder(file)
	all := All{}
	err = dec.Decode(&all)
	if err != nil {
		log.Fatal(err)
	}

	if all.Copyright == "" {
		err = errors.New("Copyright is missing")
		log.Fatal(err)
	}
	if all.Package == "" {
		err = errors.New("Package is missing")
		log.Fatal(err)
	}
	if all.Texts == nil || len(all.Texts) == 0 {
		err = errors.New("Texts are missing")
		log.Fatal(err)
	}

	makeCode(all)
	makeTestCode(all)
}

func makeCode(all All) {

	out, err := os.Create(all.GenFile)
	if err != nil {
		log.Fatal(err)
	}
	t := template.New("code")
	_, err = t.Parse(code)
	if err != nil {
		log.Fatal(err)
	}
	err = t.Execute(out, all) // create code
	if err != nil {
		log.Fatal(err)
	}
	err = out.Close()
	if err != nil {
		log.Fatal(err)
	}

	bytes, err := json.Marshal(all.Texts) // create data for dynamic resetting of the locale
	if err != nil {
		log.Fatal(err)
	}
	out, err = os.OpenFile(all.GenFile, os.O_WRONLY|os.O_APPEND, os.ModeAppend)
	if err != nil {
		log.Fatal(err)
	}
	_, err = out.Write([]byte("`"))
	if err != nil {
		log.Fatal(err)
	}
	_, err = out.Write(bytes) // append to code
	if err != nil {
		log.Fatal(err)
	}
	_, err = out.Write([]byte("`\n"))
	if err != nil {
		log.Fatal(err)
	}
	err = out.Close()
	if err != nil {
		log.Fatal(err)
	}
}

var code = `// Copyright {{.Copyright}}. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY stringl10n.
// DO NOT EDIT.
// CHANGES WILL BE LOST AFTER NEXT //go:generate stringl10n ...

/*
 {{.GenFile}} contains all localized strings and
 functions for translating (t alias l10nTranslate)
 and variable substitution (l10nSubstitute).
*/

package {{.Package}}

import (
	"encoding/json"
	"log"
	"text/template"
{{if ne (len .Funcs) 0}}{{range .Funcs}}{{if ne .Path ""}}
	"{{.Path}}"{{end}}{{end}}{{end}}
)

// Type l10nPair is used during string localization.
type l10nPair struct {
	Lang  string
	Value string
}

// l10nMap contains all key strings and all translations.
var l10nMap = make(map[string][]l10nPair, 10)

// l10nTranslate returns a translation of a given text
// according to the chosen language code.
// Errors are logged.
func l10nTranslate(key, lang string) (value string) {
	pairs, ok := l10nMap[key]
	if !ok {
		log.Print("No entry for (text): " + key)
		return key
	}
	for _, v := range pairs {
		if v.Lang == lang {
			return v.Value
		}
	}
	log.Print("No entry for (language/text): " + lang + " / " + key)
	return key
}

// t conveniently points to the translate function.
var t = l10nTranslate

// l10nVars declares all variables needed for substitution.
type l10nVars struct { {{range .Vars}}
	{{.Name}} {{.Type}}{{end}}
}

// Varser interface has a method that returns
// Name-string/Value-interface{} pairs.
type Varser interface {
	Vars() []struct{
		Name string
		Value interface{}
	}
}

// l10nSubstitute resolves text/template expressions and returns
// the changed text string. Variables in these text/template 
// expressions are substituted by values.
// Errors are logged.
func l10nSubstitute(tmpl string, vars Varser) (out string) {

	t := template.New("tmpl"){{if eq (len .Funcs) 0}}
	_, err := t.Parse(tmpl){{else}}
	funcMap := template.FuncMap { {{range .Funcs}}
		"{{.Name}}": {{.Function}},{{end}}
	}
	_, err := t.Funcs(funcMap).Parse(tmpl){{end}}
	if err != nil {
		log.Print(err)
	}

	all := l10nVars{}
	for _, v := range vars.Vars() {
		switch v.Name { {{range .Vars}}
		case "{{.Name}}":
			tmp, ok := v.Value.({{.Type}})
			if !ok {
				log.Printf("False type for variable {{.Name}}, expected: {{.Type}}, got: %T\n", v.Value)
				break
			}
			all.{{.Name}} = tmp{{end}}
		default:
			log.Printf("Variable %s not declared\n", v.Name)			
		}
	}
	
	p := l10nPointer{&out}
	err = t.Execute(p, all)
	if err != nil {
		log.Print(err)
	}

	return
}

// l10nPointer points to a string.
type l10nPointer struct {
	pointer *string
}

// Write makes l10nPointer an io.Writer
// that writes to the string it points to.
func (o l10nPointer) Write(p []byte) (n int, err error) {
	*(o.pointer) += string(p)
	n = len(p)
	return
}

func init() {
	err := json.Unmarshal([]byte(l10nJSON), &l10nMap)
	if err != nil {
		log.Fatal(err)
	}
	l10nJSON = "" // no longer needed
}

var l10nJSON = `

func makeTestCode(all All) {

	for k, v := range all.Texts {
		for i, val := range v {
			v[i].Value = strings.Replace(val.Value, `"`, "\\\"", -1)
		}
		delete(all.Texts, k)
		k = strings.Replace(k, `"`, "\\\"", -1)
		all.Texts[k] = v
	}

	out, err := os.Create(
		all.GenFile[:len(all.GenFile)-3] + "_test.go",
	)
	if err != nil {
		log.Fatal(err)
	}
	t := template.New("test")
	_, err = t.Parse(test)
	if err != nil {
		log.Fatal(err)
	}
	err = t.Execute(out, all) // create code
	if err != nil {
		log.Fatal(err)
	}
	err = out.Close()
	if err != nil {
		log.Fatal(err)
	}
}

var test = `// Copyright {{.Copyright}}. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY stringl10n.
// DO NOT EDIT.
// CHANGES WILL BE LOST AFTER NEXT //go:generate stringl10n ...

package {{.Package}}

import (
	"testing"
)

type InT struct {
	key string
	lang string
}
type tTest struct {
	in  InT
	out string
}

var tTests = []tTest{ {{range $key, $pair := .Texts}}{{range $pair}}
	{
		in: InT{key: "{{$key}}", lang: "{{.Lang}}"},
		out: "{{.Value}}",
	},{{end}}{{end}}
}

// TestT runs tests for function t.
func TestT(test *testing.T) {
	for _, v := range tTests {
		temp := t(v.in.key, v.in.lang)
		if temp != v.out {
			test.Error("Key:"+v.in.key+" Lang:"+v.in.lang+"\nexpected:"+v.out+"\ngot:     "+temp)
		}
	}
}
`
