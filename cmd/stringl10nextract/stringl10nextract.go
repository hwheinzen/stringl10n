// Copyright 2015 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// Command stringl10nextract generates output data that can be used
// as input to the string localization tool stringl10n.
//
// Output data must be edited!
//
// Usage:
//  $ find . | stringl10nextract > example.txt
// or:
//  $ stringl10nextract -root=. -o=example.txt
package main

import (
	"bufio"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	pgmname = "stringl10nextract"
	head    = `# This file was generated by stringl10nextract.
#
# Edit to make it the JSON input file for stringl10n.
#
# - change copyright owner
# - change package name
# - change GenFile name (optional)
#
# - delete entries which don't need translation
# - add translations to Texts
#
# - add variables of template expressions to Vars array
#  (if needed)
#
# - add functions of template expressions to Funcs array
#   (if needed && identical paths only once)
#
# - remove comments (no longer necessary, but nicer)
#
{
	 "Copyright": "2015 Itts Mee"
	,"Package":   "example"
	,"GenFile":   "stringl10n_generated.go"

	,"Vars": [
			 {"Name": "", "Type": ""}
			,{"Name": "", "Type": ""}
	]

	,"Funcs": [
			 {"Name": "", "Function": "", "Path": ""}
			,{"Name": "", "Function": ""}
	]

	,"Texts": {`

	foot = "\t}\n}\n"
)

// Key of the map will be the string to translate, value collects occurances.
// The map garanties uniqueness of the keys.
var gMap = make(map[string]string, 50)

func main() {

	args() // arguments global: argXxxx

	msgs, err := messages()
	if err != nil {
		log.Fatalln(pgmname+":", err)
	}

	err = createOutFile(msgs)
	if err != nil {
		log.Fatalln(pgmname+":", err)
	}
}

func messages() (msgs ByKey, err error) {

	if argDir != "" {
		// examine files, write to gMap
		err = filepath.Walk(argDir, visitFile)
		if err != nil {
			return
		}
	} else {
		// examine stdin
		s := bufio.NewScanner(os.Stdin)
		for s.Scan() {
			path := s.Text()
			var fi os.FileInfo
			fi, err = os.Stat(path)
			if err != nil {
				return
			}
			// write to gMap
			err = visitFile(path, fi, err)
		}
	}

	// slice for alle msgs
	//msgs = make([]Elem, 0, len(gMap))
	for k, v := range gMap {
		msgs = append(msgs, Elem{Key: k, Value: v})
	}
	// sort by key
	ByKeySort(msgs)

	return
}

func createOutFile(msgs ByKey) (err error) {

	var file *os.File

	if argOut != "" {
		// to file
		file, err = os.Create(argOut)
		if err != nil {
			return
		}
		defer file.Close()
	} else {
		// to stdout
		file = os.Stdout
	}

	fmt.Fprintln(file, head)

	for i, v := range msgs {
		if i == 0 {
			fmt.Fprintln(file, "\t\t \""+v.Key+"\": [")
		} else {
			fmt.Fprintln(file, "\t\t,\""+v.Key+"\": [")
		}
		if argLang != "" {
			fmt.Fprintln(
				file,
				"\t\t\t {\"Lang\":\""+argLang+"\",\"Value\":\""+v.Key+"\"}",
			)
		}
		fmt.Fprintln(file, "\t\t\t,{\"Lang\":\"\",\"Value\":\"\"}")
		fmt.Fprintln(file, v.Value)
		fmt.Fprintln(file, "\n\t\t]")
	}

	fmt.Fprintln(file, foot)

	return
}

func visitFile(path string, fi os.FileInfo, inErr error) (err error) {

	if inErr != nil {
		err = inErr
		return
	}

	if len(path) > 1 && path[:2] == "./" {
		path = path[2:]
	}

	if isGoFile(fi) {
		if path == fi.Name() || argDeep {
			// process file or dive into subdir
			//
			// processInFile returns error from parser.ParseFile
			// which makes filepath.Walk go on to the next ...
			err = processInFile(path)
		}
	}
	return
}

func isGoFile(fi os.FileInfo) bool {
	name := fi.Name()
	return !fi.IsDir() &&
		!strings.HasPrefix(name, ".") &&
		strings.HasSuffix(name, ".go") &&
		!strings.HasSuffix(name, "test.go")
}

func processInFile(path string) (err error) {

	// create AST
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, path, nil, 0)
	// directories return error!
	if err != nil {
		return
	}

	// inspect AST
	ast.Inspect(
		f,
		func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.GenDecl:
				if x.Tok == token.IMPORT {
					return false
				}
			case *ast.BasicLit:
				if x.Kind == token.STRING {
					// process string literals
					return processString(
						n,
						fset,
						x.Value[1:len(x.Value)-1],
					)
				}
			}
			return true
		},
	)
	return
}

// processString prints relevant strings JSON-formatted to the output file.
func processString(n ast.Node, fset *token.FileSet, s string) bool {

	runes := []rune(s)
	if len(runes) < argMin+2 {
		// probably not worth translating
		return false
	}
	if len(runes) > argMax+2 {
		// probably not intended for translation
		return false
	}

	if argKeywords != nil {
		ok := false
		for _, v := range argKeywords {
			if strings.Contains(s, v) {
				// keyword inside
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	if gRgx != nil && !gRgx.MatchString(s) {
		// match
		return false
	}

	v, ok := gMap[s]
	if !ok {
		// new entry
		gMap[s] = "\n\t\t # " + fmt.Sprint(fset.Position(n.Pos()))
	} else {
		// add position
		gMap[s] = v + "\n\t\t # " + fmt.Sprint(fset.Position(n.Pos()))
	}

	return true
}
