// Copyright 2015 Hans-Werner Heinzen. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

package main

import (
	"encoding/json"
	"errors"
	"log"
	"os"
	"text/template"
)

const (
	pgmname = "stringl10n"
)

type Pair struct {
	Lang    string
	Value string
}
type Phrase struct {
	Name string
	Locs []Pair
}
type All struct {
	Copyright string
	Package   string
	GenFile   string
	Default   string
	Start     string
	Text      []Phrase
}

func main() {

	fn := args()

	file, err := os.Open(fn)
	if err != nil {
		log.Fatal(err)
	}

	dec := json.NewDecoder(file)
	all := All{}
	err = dec.Decode(&all)
	if err != nil {
		log.Fatal(err)
	}

	if all.Copyright == "" {
		err = errors.New("Copyright is missing")
		log.Fatal(err)
	}
	if all.Package == "" {
		err = errors.New("Package is missing")
		log.Fatal(err)
	}
	if all.Default == "" {
		err = errors.New("Default language code is missing")
		log.Fatal(err)
	}
	if all.Start == "" {
		err = errors.New("Start language code is missing")
		log.Fatal(err)
	}

	out, err := os.Create(all.GenFile)
	if err != nil {
		log.Fatal(err)
	}
	t := template.New("tmpl")
	_, err = t.Parse(tmpl)
	if err != nil {
		log.Fatal(err)
	}
	err = t.Execute(out, all) // create code
	if err != nil {
		log.Fatal(err)
	}
	err = out.Close()
	if err != nil {
		log.Fatal(err)
	}

	bytes, err := json.Marshal(all.Text) // create data for dynamic resetting of the locale
	if err != nil {
		log.Fatal(err)
	}
	out, err = os.OpenFile(all.GenFile, os.O_WRONLY|os.O_APPEND, os.ModeAppend)
	if err != nil {
		log.Fatal(err)
	}
	_, err = out.Write([]byte("`"))
	if err != nil {
		log.Fatal(err)
	}
	_, err = out.Write(bytes)
	if err != nil {
		log.Fatal(err)
	}
	_, err = out.Write([]byte("`\n"))
	if err != nil {
		log.Fatal(err)
	}
	err = out.Close()
	if err != nil {
		log.Fatal(err)
	}
}

var tmpl = `// Copyright {{.Copyright}}. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.

// THIS FILE HAS BEEN GENERATED BY stringl10n.
// DO NOT EDIT.
// CHANGES WILL BE LOST AFTER NEXT //go:generate stringl10n.

/*
 {{.GenFile}} contains all localized Strings and a set method.
*/

package {{.Package}}

import (
	"errors"
	"encoding/json"
	"log"
)

var ({{/*
*/}}{{range $i, $phrase := .Text}}
	{{$phrase.Name}} string{{/*
*/}}{{end}}
){{/*
*/}}{{$start := .Start}}{{/*
*/}}{{$default := .Default}}{{/*
*/}}

// Type L10nPair is used during string localization.
type L10nPair struct {
	Lang  string
	Value string
}
// Type L10nPhrase is used during string localization.
type L10nPhrase struct {
	Name string
	Locs []L10nPair
}
// Type L10nText is used during string localization.
type L10nText []L10nPhrase

// l10nLocal returns a localized text for a given variable
// according to the chosen locale language codes.
func (t *L10nText) l10nLocal(name, loc, def string) (value string, err error) {
	for _, v := range *t {
		if v.Name == name {
			for _, w := range v.Locs {
				if w.Lang == loc {
					value = w.Value
					return
				}
				if w.Lang == def && value == "" { // default
					value = w.Value
				}
			}
		}
	}
	return "", errors.New("Unrecognized locale <" + loc + ">")
}

// L10nSetLocale sets all localized string variables according
// to the chosen locale language codes.
func L10nSetLocale(loc, def string) (err error) { 
	t := &L10nText{}
	err = json.Unmarshal([]byte(l10nJSON), t)
	if err != nil {
		return
	}{{/*
*/}}{{range $i, $phrase := .Text}}
	{{$phrase.Name}}, err = t.l10nLocal("{{$phrase.Name}}", loc, def)
	if err != nil {
		return
	}{{/*
*/}}{{end}}
	return
}

func init() {
	err := L10nSetLocale("{{$start}}", "{{$default}}")
	if err != nil {
		log.Fatal(err)
	}
}

const l10nJSON = `
